## 통신 구성시 중요 쟁점

### 하위 호환성을 쉽게
마이크로서비스 변경시 이를 소비하는 마이크로서비스와 호환성이 깨지지 않아야한다<br/>
그러므로 하위 호환되는 변경을 쉽게 만들고, 변경이 호환되는지 검증할 수 있고, 배포하기 전 피드백이 가능하도록 해야한다
<br/><br/>

### 명시적 인터페이스
마이크로서비스가 노출하는 인터페이스는 소비자가 분명하게 알아야한다<br/>
명시적 스키마를 사용하면 인터페이스가 분명하다는 것을 보장할 때 큰 도움이 된다
<br/><br/>

### 기술 중립적인 API
IT업계는 급변하고 있다, 언제 다른 기술을 도입하고 싶을지 모르니 API 구성시 기술 스택을 강요하는 통합 기술은 피해야한다
<br/><br/>

### 소비자를 위한 단순한 서비스
소비자가 마이크로서비스를 사용하는데 필요한 비용이 어마어마하게 높다면, 서비스의 사용성이 떨어져 문제가 많다<br/>
하지만 소비자가 쉽게 사용할 수 있도록 클라이언트 라이브러리를 제공할 경우 결합이 증가한다는 점을 고려해야한다
<br/><br/>

### 내부 구현을 숨겨라
소비자가 내부 구현에 종속된다면, 마이크로서비스 내부의 무언가를 변경하면 쇱자도 변경을 해야하므로 변경의 난이도가 높아진다<br/>
내부 표현의 상세 정보를 노출하는 것을 강요하는 기술을 피해야한다
<br/><br/>

## 기술 선택

### RPC
RPC는 로컬 호출을 통해 원격 서비스를 실행하는 기술이다<br/>
명시적 스키마를 사용하여 원격 호출을 로컬 호출처럼 보이도록 하는 특성을 가지고 있고, 이를 위해 직렬화 프로토콜을 사용한다<br/>
명시적 스키마가 있을 경우 스스로 코드를 생성할 수 있어 클라이언트가 스키마를 가져올 수만 있다면 클라이언트 라이브러리가 필요없다<br/>
<br/><br/>

단점으로는 
- 일부 RPC 프로토콜의 경우 사용가능한 언어가 제한되어있어 상호 운용성의 제약이 있을 수 있다
- 로컬 호출처럼 보이기 때문에 네트워크 전송과 마샬링/언마샬링에서 큰 비용이 들고, 네트워크가 신뢰할 수 없다는 점을 간과할 수 있다
- 스키마가 변경될 경우 클라이언트와 서버 배포를 분리할 수 없다(그렇지않으면 깨진다) 따라서 락스텝 릴리스를 고려해야한다
<br/><br/>

### REST
리소스가 외부에 표시되는 방식은 내부에 저장되는 방식과 별개이다<br/>
HATEOAS는 rel:href KV쌍으로 저장하여 href 링크가 변하더라도 rel은 그대로 유지하여 REST의 변경에도 클라이언트는 변경이 필요없도록한다<br/>
즉 링크에 해당하는 url은 일반적인 REST로 구성하고 클라이언트가 쉽게 이 링크들을 찾을 수 있도록 구성해줄 때는 HATEOAS로 하는 방식이다<br/>
![image](https://github.com/dik654/Kubernetes_study/assets/33992354/b3e269a2-a83b-4f5d-9d14-b61ca3291d1d)

단점으로는
- HTTP 요청마다 생기는 오버헤드로 낮은 지연 시간이 필요할 경우 문제가 있을 수 있다
- HATEOAS 사용시 클라이언트가 정확한 엔드포인트를 찾기위해 여러 컨트롤을 탐색하여 성능 문제가 생길 수 있다
<br/><br/>

### GraphQL
클라이언트가 쿼리를 정의하여 정보의 노출 과다와 노출 부족, 동일한 검색을 위해 여러 번의 요청을 할 필요가 없도록 한다.

단점으로는
- 서버에서 쿼리를 분석해야하므로 서버 부하가 늘어나고, 복잡한 쿼리에서 문제가 생겼을 경우 어떤 부분에서 문제가 생겼는지 추적이 쉽지않다<br/>
- 쓰기 작업의 경우 적합성이 떨어져 쓰기는 REST로 하는 경우가 생길 수 있다<br/>
- GraphQL을 DB의 API라고 생각하면 안된다, API와 DB가 결합되지 않는 것이 중요하다(클라이언트가 요청할 수 있는 데이터 타입과 필드를 정의하지만, 데이터가 어떻게 저장되거나 검색되는지에 대해서는 정의하지 않는다)
<br/><br/>

### 메세지 브로커
프로세스 사이에서 프로세스 간 통신을 관리하는 미들웨어<br/>
토픽, 큐를 사용하는데 <br/>
큐는 발신자와 소비자 간 1:1 전송으로 볼 수 있고,<br/>
토픽은 발신자와 소비자(구독자)들 간의 1:N 전송이라고 볼 수 있다<br/>
큐를 사용할 때는 발신자가 소비자의 정보를 알고 있지만 토픽에서는 소비자의 정보를 모른다<br/>
따라서 토픽은 이벤트 기반, 큐는 요청 및 응답 통신에 적합하다<br/>
브로커는 메세지를 전달할 때까지 유지하는 전달 보장 기능을 갖기에 근본적으로 비동기 통신에 매우 유용하다
<br/><br/>

## 스키마
XML로 작업할 경우 XSD, JSON으로 작업할 때는 JSON 스키마, SOAP는 WSDL, gRPC는 protocol buffer 명세가 필요하다<br/>
마이크로서비스의 엔드포인트에 명시적 스키마를 사용하는 것은 엔드포인트의 우발적 파손을 감지하는데 도움이 된다

엔드포인트의 계약 위반은 구조적 위반과 의미적 위반으로 나뉜다
- 구조적 위반 : 소비자에게 호환되지않는 방식으로 엔드 포인트의 구조를 변경하는 것
- 의미적 위반 : 구조는 동일하지만 소비자의 기대와 다르게 동작하는 것

## 마이크로서비스 간 계약 변경
마이크로서비스 변경에 있어 중단 변경을 피하려면 아래 과정들이 필요하다

### 확장 변경
새로운 것만 추가하고 제거는 하지않는 방식을 말한다, 일반적으로 새 필드가 추가되는 것은 문제가 되지만 있던 필드를 제거할 경우 큰 문제가 된다
<br/><br/>

### tolerant reader pattern
optional field 설정 등을 이용하여 소비자가 관심 없는 변경 사항은 무시할 수 있도록 하는 패턴이다
<br/><br/>

### 우발적인 중단 변경 일찍 발견하기
정상적인 변경으로도 소비자가 중단될 수 있어, 가능한 빠르게 소비자 중단 변경을 파악하는 것이 중요하다<br/>
confluent schema registry같은 스키마 비교 도구는 스키마를 비교하여 구조적 위반이 있는지 검사하는데 도움이 된다.
<br/><br/>

## 중단 변경 관리하기

### lockstep deployment
공급자 마이크로서비스와 소비자 마이크로서비스를 동시에 변경하는 것으로,<br/>
너무 자주 할 경우 서비스들이 분산형 모놀리스가 될 위험이 있다
<br/><br/>

### 호환되지 않는 마이크로서비스 버전의 공존
이전 버전과 새 버전을 나란히 실행하여 이전 버전 소비자는 이전 버전 마이크로서비스로 라우팅하는 방식으로 동작시킨다<br/>
단점으로는 버그를 수정해야할 때 두 서비스를 모두 수정해야하고, 내부적으로 nginx를 사용하게되어 시스템 동작을 추론하기 힘들어진다
<br/><br/>

### 기존 인터페이스 에뮬레이션
새로운 마이크로서비스가 새 인터페이스를 노출하고 기존 인터페이스를 에뮬레이트하도록하는 방식으로<br/>
단점은 관리해야하는 코드의 양이 2배가 되었다는 점이다
<br/><br/>

### 사회적 계약
변경 사항을 어떻게 처리할 것인지에 대한 합의는 몇 가지 사안을 고려해야한다
- 인터페이스 변경 이슈는 어떻게 제기할 것인가?
- 소비자와 마이크로서비스 팀이 변경 사항에 동의하도록 어떻게 합의할 것인가?
- 누가 작업을 할 것인가?
- 전환까지 얼마나 걸리는가?

그 와중에도 효율적인 마이크로서비스를 위해서는 소비자를 우선하는 것이 가장 중요하다
<br/><br/>

### 사용성 추적
만약 오래된 인터페이스를 새 인터페이스로 이전하는 작업을 한다면, 엔드포인트에 로그인을 보장하는 로직을 추가하면 소비자가 실제로 사용을 중단했는지 확인하는데 도움이 된다
<br/><br/>

### 극단적 조치
소비자가 여전히 오래된 인터페이스를 사용 중이지만 무시하고 엔드포인트를 끄자는 결정이 생기는 경우라도, 누가 영향을 받고 있는지 추적할 수 있어야한다<br/>
저항을 줄이는 한 방법으로는 기간이 지날수록 오래된 라이브러리의 응답 속도를 늦어지도록 로직을 추가하여 사용자의 불편을 유도하여 인터페이스 업데이트를 유도하는 방법이 있다<br/>
<br/><br/>

## 마이크로서비스에서 DRY와 코드 재사용의 위험

### 라이브러리를 이용한 코드 공유
공유 코드를 사용할 경우 마이크로서비스와 소비자와 결합이 생길 수 있다<br/>
공유 코드가 서비스 경계 외부로 새어나가 사용되면 잠재적 형태의 결합이 생겨난다<br/>
또한 라이브러리를 이용해 코드 공유를 할 경우 라이브러리를 한 번에 업데이트할 수 없다, 여러 버전의 라이브러리가 동시에 존재할 수 있다는 사실을 받아들여야 한다<br/>

클라이언트 라이브러리를 사용할 경우, 클라이언트 라이브러리에 더 많은 로직이 들어갈수록 서버 수정시 클라이언트도 같이 변경해야할 것이다<br/>
넷플릭스 클라이언트 라이브러리는 서비스 디스커버리, 실패 모드, 로깅 같은 서비스와는 관련없는 것만 처리하도록 했지만 그럼에도 시간이 지나면서 결합이 어느정도 생겨 문제가 발생했다고 한다<br/>
<br/><br/>
## 서비스 메시와 API 게이트웨이
API 게이트웨이나 서비스 메시로 공유 코드를 작성할 경우, 이 동작이 완전히 범용적이어야한다
<br/><br/>

### API 게이트웨이
API 게이트웨이는 서비스 외부와 서비스 내부 간의 트래픽을 처리하며 대부분 리버스 프록시로 동작한다<br/>
여러 호출을 하고 결과를 집계 및 필터링 할 때 API 게이트웨이 계층에서 해결하고 싶을 수 있지만, <br/>
API는 파이프이므로 `파이프는 멍청하게, 엔드포인트는 똑똑하게 유지한다`라는 규칙을 위반한다.<br/>
API 게이트웨이로 유입된 동작이 많을수록 핸드오프의 조정이 증가하고 제공 속도가 저하될 위험도가 높아진다<br/>
또 한가지 주의사항은 API 게이트웨이를 모든 마이크로서비스간 호출 중개자로 사용할 경우 하나 이상의 네트워크 홉을 추가한 것이므로 네트워크 지연 시간과 오버헤드를 고려해야한다<br/>
<br/><br/>

### 서비스 메시
서비스 메시는 마이크로서비스 내부 서비스 간 통신을 세밀하게 처리하며 마이크로서비스 간 통신과 관련된 공통 기능이 메시로 푸시된다<br/>
공통 기능에는 mutual TLS, correlation ID, 서비스 디스커버리, 로드밸런싱 등이 있다<br/>
서비스 메시 사용시, 재빌드와 재배포를 하지 않고도 마이크로서비스 간 통신 측면에서 변경 사항을 훨씬 더 유연하게 롤아웃할 수 있다<br/>
서비스 메시는 프록시 간 호출로 인한 영향을 제한하려는 아키텍처를 기반으로 한다<br/>
컨트롤 플레인은 로컬 메시 프록시 위에서 프록시 동작을 변경하고 프록시 작업 정보를 수집하는 곳이다<br/>
구현체로는 envoy 프록시를 많이 사용한다<br/>

서비스 메시의 단점으로는 쿠버네티스를 사용하지 않으면 옵션이 제한되며 복잡성이 더 증가한다는 점이다
