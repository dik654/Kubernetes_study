## 통신 구성시 중요 쟁점

### 하위 호환성을 쉽게
마이크로서비스 변경시 이를 소비하는 마이크로서비스와 호환성이 깨지지 않아야한다<br/>
그러므로 하위 호환되는 변경을 쉽게 만들고, 변경이 호환되는지 검증할 수 있고, 배포하기 전 피드백이 가능하도록 해야한다
<br/><br/>

### 명시적 인터페이스
마이크로서비스가 노출하는 인터페이스는 소비자가 분명하게 알아야한다<br/>
명시적 스키마를 사용하면 인터페이스가 분명하다는 것을 보장할 때 큰 도움이 된다
<br/><br/>

### 기술 중립적인 API
IT업계는 급변하고 있다, 언제 다른 기술을 도입하고 싶을지 모르니 API 구성시 기술 스택을 강요하는 통합 기술은 피해야한다
<br/><br/>

### 소비자를 위한 단순한 서비스
소비자가 마이크로서비스를 사용하는데 필요한 비용이 어마어마하게 높다면, 서비스의 사용성이 떨어져 문제가 많다<br/>
하지만 소비자가 쉽게 사용할 수 있도록 클라이언트 라이브러리를 제공할 경우 결합이 증가한다는 점을 고려해야한다
<br/><br/>

### 내부 구현을 숨겨라
소비자가 내부 구현에 종속된다면, 마이크로서비스 내부의 무언가를 변경하면 쇱자도 변경을 해야하므로 변경의 난이도가 높아진다<br/>
내부 표현의 상세 정보를 노출하는 것을 강요하는 기술을 피해야한다
<br/><br/>

## 기술 선택

### RPC
RPC는 로컬 호출을 통해 원격 서비스를 실행하는 기술이다<br/>
명시적 스키마를 사용하여 원격 호출을 로컬 호출처럼 보이도록 하는 특성을 가지고 있고, 이를 위해 직렬화 프로토콜을 사용한다<br/>
명시적 스키마가 있을 경우 스스로 코드를 생성할 수 있어 클라이언트가 스키마를 가져올 수만 있다면 클라이언트 라이브러리가 필요없다<br/>
<br/><br/>

단점으로는 
- 일부 RPC 프로토콜의 경우 사용가능한 언어가 제한되어있어 상호 운용성의 제약이 있을 수 있다
- 로컬 호출처럼 보이기 때문에 네트워크 전송과 마샬링/언마샬링에서 큰 비용이 들고, 네트워크가 신뢰할 수 없다는 점을 간과할 수 있다
- 스키마가 변경될 경우 클라이언트와 서버 배포를 분리할 수 없다(그렇지않으면 깨진다) 따라서 락스텝 릴리스를 고려해야한다
<br/><br/>

### REST
리소스가 외부에 표시되는 방식은 내부에 저장되는 방식과 별개이다<br/>
HATEOAS는 rel:href KV쌍으로 저장하여 href 링크가 변하더라도 rel은 그대로 유지하여 REST의 변경에도 클라이언트는 변경이 필요없도록한다<br/>
즉 링크에 해당하는 url은 일반적인 REST로 구성하고 클라이언트가 쉽게 이 링크들을 찾을 수 있도록 구성해줄 때는 HATEOAS로 하는 방식이다<br/>
![image](https://github.com/dik654/Kubernetes_study/assets/33992354/b3e269a2-a83b-4f5d-9d14-b61ca3291d1d)

단점으로는
- HTTP 요청마다 생기는 오버헤드로 낮은 지연 시간이 필요할 경우 문제가 있을 수 있다
- HATEOAS 사용시 클라이언트가 정확한 엔드포인트를 찾기위해 여러 컨트롤을 탐색하여 성능 문제가 생길 수 있다
<br/><br/>

### GraphQL
클라이언트가 쿼리를 정의하여 정보의 노출 과다와 노출 부족, 동일한 검색을 위해 여러 번의 요청을 할 필요가 없도록 한다.

단점으로는
- 서버에서 쿼리를 분석해야하므로 서버 부하가 늘어나고, 복잡한 쿼리에서 문제가 생겼을 경우 어떤 부분에서 문제가 생겼는지 추적이 쉽지않다
- 쓰기 작업의 경우 적합성이 떨어져 쓰기는 REST로 하는 경우가 생길 수 있다
- GraphQL을 DB의 API라고 생각하면 안된다, API와 DB가 결합되지 않는 것이 중요하다(클라이언트가 요청할 수 있는 데이터 타입과 필드를 정의하지만, 데이터가 어떻게 저장되거나 검색되는지에 대해서는 정의하지 않는다)
<br/><br/>

### 메세지 브로커
프로세스 사이에서 프로세스 간 통신을 관리하는 미들웨어<br/>
토픽, 큐를 사용하는데 <br/>
큐는 발신자와 소비자 간 1:1 전송으로 볼 수 있고,<br/>
토픽은 발신자와 소비자(구독자)들 간의 1:N 전송이라고 볼 수 있다<br/>
큐를 사용할 때는 발신자가 소비자의 정보를 알고 있지만 토픽에서는 소비자의 정보를 모른다<br/>
따라서 토픽은 이벤트 기반, 큐는 요청 및 응답 통신에 적합하다<br/>
브로커는 메세지를 전달할 때까지 유지하는 전달 보장 기능을 갖기에 근본적으로 비동기 통신에 매우 유용하다

## 스키마
XML로 작업할 경우 XSD, JSON으로 작업할 때는 JSON 스키마, SOAP는 WSDL, gRPC는 protocol buffer 명세가 필요하다
마이크로서비스의 엔드포인트에 명시적 스키마를 사용하는 것은 엔드포인트의 우발적 파손을 감지하는데 도움이 된다

엔드포인트의 계약 위반은 구조적 위반과 의미적 위반으로 나뉜다
- 구조적 위반 : 소비자에게 호환되지않는 방식으로 엔드 포인트의 구조를 변경하는 것
- 의미적 위반 : 구조는 동일하지만 소비자의 기대와 다르게 동작하는 것

## 마이크로서비스 간 계약 변경
마이크로서비스 변경에 있어 중단 변경을 피하려면 아래 과정들이 필요하다

### 확장 변경
새로운 것만 추가하고 제거는 하지않는 방식을 말한다, 일반적으로 새 필드가 추가되는 것은 문제가 되지만 있던 필드를 제거할 경우 큰 문제가 된다

### tolerant reader pattern
optional field 설정 등을 이용하여 소비자가 관심 없는 변경 사항은 무시할 수 있도록 하는 패턴이다

### 우발적인 중단 변경 일찍 발견하기
정상적인 변경으로도 소비자가 중단될 수 있어, 가능한 빠르게 소비자 중단 변경을 파악하는 것이 중요하다
confluent schema registry같은 스키마 비교 도구는 스키마를 비교하여 구조적 위반이 있는지 검사하는데 도움이 된다.

## 중단 변경 관리하기

### lockstep deployment

### 호환되지 않는 마이크로서비스 버전의 공존

### 기존 인터페이스 에뮬레이션

